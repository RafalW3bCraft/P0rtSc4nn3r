"""
Vulnerability Scanner for P0rt$c4nn3r
Basic vulnerability detection for common services
"""

import socket
import re
import ssl
import time
from threading import Lock

class VulnerabilityScanner:
    """Basic vulnerability detection for common services"""
    
    def __init__(self):
        self.lock = Lock()
        self.vulnerability_db = self._build_vulnerability_database()
        
    def scan_vulnerabilities(self, target, port, service, timeout=3.0):
        """Scan for basic vulnerabilities on a specific port"""
        vulnerabilities = []
        banner = self._grab_banner(target, port, timeout)
        
        if banner:
            vulnerabilities.extend(self._check_banner_vulnerabilities(banner, service, port))
            
        # Service-specific vulnerability checks
        vulnerabilities.extend(self._check_service_vulnerabilities(target, port, service, timeout))
        
        return {
            'port': port,
            'service': service,
            'banner': banner,
            'vulnerabilities': vulnerabilities
        }
        
    def _grab_banner(self, target, port, timeout=3.0):
        """Grab service banner for analysis"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((target, port))
            
            # Send appropriate probe based on port
            probe = self._get_service_probe(port)
            if probe:
                sock.send(probe.encode())
                
            # Receive banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            return banner
            
        except Exception:
            return None
            
    def _get_service_probe(self, port):
        """Get appropriate probe for service detection"""
        probes = {
            21: "USER anonymous\r\n",
            22: "",  # SSH sends banner immediately
            23: "",  # Telnet sends banner immediately
            25: "EHLO test\r\n",
            53: "",  # DNS doesn't respond to simple TCP
            80: "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n",
            110: "USER test\r\n",
            143: "A001 CAPABILITY\r\n",
            443: "",  # HTTPS needs SSL handshake
            993: "",  # IMAPS needs SSL handshake
            995: "",  # POP3S needs SSL handshake
        }
        return probes.get(port, "")
        
    def _check_banner_vulnerabilities(self, banner, service, port):
        """Check banner for known vulnerability indicators"""
        vulnerabilities = []
        banner_lower = banner.lower()
        
        # Check version-based vulnerabilities
        for vuln_pattern, vuln_info in self.vulnerability_db.get('banner_patterns', {}).items():
            if re.search(vuln_pattern, banner_lower):
                vulnerabilities.append({
                    'type': 'version_vulnerability',
                    'severity': vuln_info['severity'],
                    'description': vuln_info['description'],
                    'recommendation': vuln_info['recommendation']
                })
                
        # Check for default credentials indicators
        if any(indicator in banner_lower for indicator in ['default', 'admin', 'password']):
            vulnerabilities.append({
                'type': 'default_credentials',
                'severity': 'medium',
                'description': 'Service may be using default credentials',
                'recommendation': 'Change default credentials and harden authentication'
            })
            
        return vulnerabilities
        
    def _check_service_vulnerabilities(self, target, port, service, timeout):
        """Check for service-specific vulnerabilities"""
        vulnerabilities = []
        
        # HTTP/HTTPS security headers check
        if port in [80, 443, 8080, 8443]:
            vulnerabilities.extend(self._check_http_security(target, port, timeout))
            
        # SSH version check
        if port in [22, 2222]:
            vulnerabilities.extend(self._check_ssh_security(target, port, timeout))
            
        # FTP anonymous access check
        if port == 21:
            vulnerabilities.extend(self._check_ftp_security(target, port, timeout))
            
        # SMTP open relay check
        if port == 25:
            vulnerabilities.extend(self._check_smtp_security(target, port, timeout))
            
        return vulnerabilities
        
    def _check_http_security(self, target, port, timeout):
        """Check HTTP security headers and configurations"""
        vulnerabilities = []
        
        try:
            # Create appropriate socket (HTTP or HTTPS)
            if port in [443, 8443]:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                sock = context.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM))
            else:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                
            sock.settimeout(timeout)
            sock.connect((target, port))
            
            # Send HTTP request
            request = f"GET / HTTP/1.1\r\nHost: {target}\r\nUser-Agent: P0rt$c4nn3r\r\n\r\n"
            sock.send(request.encode())
            
            response = sock.recv(4096).decode('utf-8', errors='ignore')
            sock.close()
            
            headers = response.lower()
            
            # Check for missing security headers
            security_headers = {
                'x-frame-options': 'Missing X-Frame-Options header (Clickjacking protection)',
                'x-content-type-options': 'Missing X-Content-Type-Options header',
                'x-xss-protection': 'Missing X-XSS-Protection header',
                'strict-transport-security': 'Missing HSTS header (HTTPS only)',
                'content-security-policy': 'Missing Content-Security-Policy header'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    # Skip HSTS check for HTTP
                    if header == 'strict-transport-security' and port not in [443, 8443]:
                        continue
                        
                    vulnerabilities.append({
                        'type': 'missing_security_header',
                        'severity': 'low',
                        'description': description,
                        'recommendation': f'Add {header} header to improve security'
                    })
                    
            # Check for server information disclosure
            if 'server:' in headers:
                server_line = [line for line in response.split('\n') if line.lower().startswith('server:')]
                if server_line:
                    vulnerabilities.append({
                        'type': 'information_disclosure',
                        'severity': 'low',
                        'description': f'Server header reveals information: {server_line[0].strip()}',
                        'recommendation': 'Hide or minimize server version information'
                    })
                    
        except Exception:
            pass
            
        return vulnerabilities
        
    def _check_ssh_security(self, target, port, timeout):
        """Check SSH security configuration"""
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((target, port))
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            
            if banner:
                # Check for old SSH versions
                if 'ssh-1.' in banner.lower():
                    vulnerabilities.append({
                        'type': 'outdated_protocol',
                        'severity': 'high',
                        'description': 'SSH version 1.x detected (deprecated and insecure)',
                        'recommendation': 'Upgrade to SSH version 2.x immediately'
                    })
                    
                # Check for version disclosure
                vulnerabilities.append({
                    'type': 'version_disclosure',
                    'severity': 'low',
                    'description': f'SSH version disclosed: {banner}',
                    'recommendation': 'Consider hiding SSH version information'
                })
                
        except Exception:
            pass
            
        return vulnerabilities
        
    def _check_ftp_security(self, target, port, timeout):
        """Check FTP security configuration"""
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((target, port))
            
            # Get initial banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Try anonymous login
            sock.send(b"USER anonymous\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if '230' in response or 'anonymous' in response.lower():
                vulnerabilities.append({
                    'type': 'anonymous_access',
                    'severity': 'medium',
                    'description': 'FTP allows anonymous access',
                    'recommendation': 'Disable anonymous FTP access if not required'
                })
                
            sock.close()
            
        except Exception:
            pass
            
        return vulnerabilities
        
    def _check_smtp_security(self, target, port, timeout):
        """Check SMTP security configuration"""
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((target, port))
            
            # Get initial banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Check SMTP capabilities
            sock.send(b"EHLO test\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Simple open relay check
            sock.send(b"MAIL FROM: test@external.com\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if '250' in response:
                sock.send(b"RCPT TO: test@anotherdomain.com\r\n")
                response = sock.recv(1024).decode('utf-8', errors='ignore')
                
                if '250' in response:
                    vulnerabilities.append({
                        'type': 'open_relay',
                        'severity': 'high',
                        'description': 'SMTP server may be configured as an open relay',
                        'recommendation': 'Configure SMTP relay restrictions immediately'
                    })
                    
            sock.close()
            
        except Exception:
            pass
            
        return vulnerabilities
        
    def _build_vulnerability_database(self):
        """Build database of known vulnerability patterns"""
        return {
            'banner_patterns': {
                r'apache/2\.2\.[0-9]': {
                    'severity': 'medium',
                    'description': 'Apache 2.2.x detected (end-of-life)',
                    'recommendation': 'Upgrade to Apache 2.4.x or newer'
                },
                r'nginx/1\.[0-9]\.[0-9]': {
                    'severity': 'low',
                    'description': 'Nginx version disclosed',
                    'recommendation': 'Hide version information in server header'
                },
                r'microsoft-iis/[0-9]\.0': {
                    'severity': 'low',
                    'description': 'IIS version disclosed',
                    'recommendation': 'Hide version information and apply latest updates'
                },
                r'openssh_[0-6]\.[0-9]': {
                    'severity': 'medium',
                    'description': 'Potentially outdated OpenSSH version',
                    'recommendation': 'Update to latest OpenSSH version'
                },
                r'proftpd 1\.[2-3]\.[0-9]': {
                    'severity': 'medium',
                    'description': 'Potentially vulnerable ProFTPD version',
                    'recommendation': 'Update ProFTPD to latest version'
                }
            }
        }
        
    def get_vulnerability_summary(self, scan_results):
        """Generate vulnerability summary from scan results"""
        total_vulns = 0
        severity_counts = {'high': 0, 'medium': 0, 'low': 0}
        
        for result in scan_results:
            vulns = result.get('vulnerabilities', [])
            total_vulns += len(vulns)
            
            for vuln in vulns:
                severity = vuln.get('severity', 'low')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
                
        return {
            'total_vulnerabilities': total_vulns,
            'high_severity': severity_counts['high'],
            'medium_severity': severity_counts['medium'],
            'low_severity': severity_counts['low']
        }